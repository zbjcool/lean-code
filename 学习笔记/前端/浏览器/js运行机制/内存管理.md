# 内存生命周期
不管什么程序语言，内存生命周期基本是一致的：   

* 分配你所需要的内存
* 使用分配到的内存（读、写）
* 不需要时将其释放\归还

# js 的垃圾回收机制

执行环境会负责管理代码执行过程中使用的内存

垃圾收集机制的原理：找出那些不再继续使用的变量，然后释放其占用的内存。为此，垃圾收集器会按照固定的时间间隔(或代码执行中预定的收集时间)， 周期性地执行这一操作。

从2012年起，所有现代浏览器都使用了标记-清除垃圾回收算法。所有对JavaScript垃圾回收算法的改进都是基于标记-清除算法的改进，并没有改进标记-清除算法本身和它对“对象是否不再需要”的简化定义。

## 引用计数垃圾收集
这是最初级的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。

该算法有个限制：无法处理循环引用的事例。

IE 6, 7 使用引用计数方式对 DOM 对象进行垃圾回收。该方式常常造成对象被循环引用时内存发生泄漏：
该算法有个限制：无法处理循环引用的事例。在下面的例子中，两个对象被创建，并互相引用，形成了一个循环。它们被调用之后会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。
```js
function f(){
  var o = {};
  var o2 = {};
  o.a = o2; // o 引用 o2
  o2.a = o; // o2 引用 o

  return "azerty";
}

f();
```
## 标记清除
这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。

这个算法假定设置一个叫做根（root）的对象（在Javascript里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。


这个算法比前一个要好，因为“有零引用的对象”总是不可获得的，但是相反却不一定
参考上面的循环引用的例子，两个对象已经不可获得了，但是有相互引用
函数调用返回之后，两个对象从全局对象出发无法获取。因此，他们将会被垃圾回收器回收

## 性能问题

垃圾收集器是周期性运行的，而且如果为变量分配的内存数量很可观，那么回收工作量也是相当大 的。在这种情况下，确定垃圾收集的时间间隔是一个非常重要的问题。

## 内存泄露
```js
function setName() {
    name = 'Jake';
}
// 全局对象增加了一个属性，不会释放
```

```js
let name = 'Jake';
setInterval(() => {
    console.log(name); 
}, 100);
// 只要setInterval运行，name不会释放
let outer = function() {
    let name = 'Jake';
    return function() {
        return name; 
    };
};
```
```js
function createPerson(name){
    let localPerson = new Object(); 
    localPerson.name = name;
        return localPerson;
   }
let globalPerson = createPerson("Nicholas");
// do something with globalPerson
globalPerson = null;
```
// 使用完闭包置为 null

## 管理内存
js和其他语言不同，操作系统给浏览器的内存通常要少，出于安全考虑。
所以一旦数据不再有用，最好通过将其值设置为 null 来释放其引用——这个 做法叫做解除引用(dereferencing)，局部变量会在 它们离开执行环境时自动被解除引用，
解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是让值脱离 执行环境，以便垃圾收集器下次运行时将其回收。
